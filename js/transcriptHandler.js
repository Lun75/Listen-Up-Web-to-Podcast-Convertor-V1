/**
 * Transcript Handler Module
 * Formats and manages podcast script output
 */

class TranscriptHandler {
  constructor() {
    this.formatVersion = '1.0';
  }

  /**
   * Format transcript with metadata
   * @param {string} script - Generated podcast script
   * @param {Object} metadata - Content metadata
   * @returns {string} Formatted transcript
   */
  formatTranscript(script, metadata) {
    const wordCount = this.getWordCount(script);
    const readingTime = this.estimateReadingTime(wordCount);
    const timestamp = new Date().toLocaleString();

    return `# ${metadata.title}

**Source**: ${metadata.url}
**Generated**: ${timestamp}
**Reading Time**: ~${readingTime} minutes
**Word Count**: ${wordCount}
**Difficulty**: ${this.capitalizeFirst(metadata.difficulty || 'medium')}
**Length**: ${this.capitalizeFirst(metadata.length || 'medium')}
${metadata.author ? `**Author**: ${metadata.author}` : ''}
${metadata.publishDate ? `**Published**: ${metadata.publishDate}` : ''}

---

${script}

---

*Generated by Listen Up! Podcast Converter*
*Format Version: ${this.formatVersion}*
`;
  }

  /**
   * Format transcript as Markdown
   * @param {string} script - Generated podcast script
   * @param {Object} metadata - Content metadata
   * @returns {string} Markdown formatted transcript
   */
  formatAsMarkdown(script, metadata) {
    return this.formatTranscript(script, metadata);
  }

  /**
   * Format transcript as plain text
   * @param {string} script - Generated podcast script
   * @param {Object} metadata - Content metadata
   * @returns {string} Plain text transcript
   */
  formatAsPlainText(script, metadata) {
    const wordCount = this.getWordCount(script);
    const readingTime = this.estimateReadingTime(wordCount);
    const timestamp = new Date().toLocaleString();

    return `${metadata.title}

Source: ${metadata.url}
Generated: ${timestamp}
Reading Time: ~${readingTime} minutes
Word Count: ${wordCount}
Difficulty: ${this.capitalizeFirst(metadata.difficulty || 'medium')}
Length: ${this.capitalizeFirst(metadata.length || 'medium')}
${metadata.author ? `Author: ${metadata.author}` : ''}
${metadata.publishDate ? `Published: ${metadata.publishDate}` : ''}

${'='.repeat(70)}

${script}

${'='.repeat(70)}

Generated by Listen Up! Podcast Converter
`;
  }

  /**
   * Format transcript as HTML
   * @param {string} script - Generated podcast script
   * @param {Object} metadata - Content metadata
   * @returns {string} HTML formatted transcript
   */
  formatAsHTML(script, metadata) {
    const wordCount = this.getWordCount(script);
    const readingTime = this.estimateReadingTime(wordCount);
    const timestamp = new Date().toLocaleString();

    // Convert script paragraphs to HTML
    const scriptHTML = script
      .split('\n\n')
      .map(para => `<p>${this.escapeHTML(para)}</p>`)
      .join('\n');

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHTML(metadata.title)} - Podcast Script</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .metadata {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .metadata p {
            margin: 5px 0;
        }
        .metadata strong {
            color: #2c3e50;
        }
        .script {
            margin: 30px 0;
        }
        .script p {
            margin: 15px 0;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9em;
        }
        hr {
            border: none;
            border-top: 2px solid #ecf0f1;
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <h1>${this.escapeHTML(metadata.title)}</h1>

    <div class="metadata">
        <p><strong>Source:</strong> <a href="${this.escapeHTML(metadata.url)}">${this.escapeHTML(metadata.url)}</a></p>
        <p><strong>Generated:</strong> ${this.escapeHTML(timestamp)}</p>
        <p><strong>Reading Time:</strong> ~${readingTime} minutes</p>
        <p><strong>Word Count:</strong> ${wordCount}</p>
        <p><strong>Difficulty:</strong> ${this.capitalizeFirst(metadata.difficulty || 'medium')}</p>
        <p><strong>Length:</strong> ${this.capitalizeFirst(metadata.length || 'medium')}</p>
        ${metadata.author ? `<p><strong>Author:</strong> ${this.escapeHTML(metadata.author)}</p>` : ''}
        ${metadata.publishDate ? `<p><strong>Published:</strong> ${this.escapeHTML(metadata.publishDate)}</p>` : ''}
    </div>

    <hr>

    <div class="script">
        ${scriptHTML}
    </div>

    <hr>

    <div class="footer">
        <p>Generated by <strong>Listen Up! Podcast Converter</strong></p>
        <p>Format Version: ${this.formatVersion}</p>
    </div>
</body>
</html>`;
  }

  /**
   * Get word count
   * @param {string} text - Text to count
   * @returns {number} Word count
   */
  getWordCount(text) {
    return text.trim().split(/\s+/).length;
  }

  /**
   * Estimate reading time
   * @param {number} wordCount - Number of words
   * @param {number} wpm - Words per minute (default 150)
   * @returns {number} Reading time in minutes
   */
  estimateReadingTime(wordCount, wpm = 150) {
    return Math.ceil(wordCount / wpm);
  }

  /**
   * Capitalize first letter
   * @param {string} str - String to capitalize
   * @returns {string} Capitalized string
   */
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Escape HTML special characters
   * @param {string} text - Text to escape
   * @returns {string} Escaped text
   */
  escapeHTML(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Generate filename for transcript
   * @param {Object} metadata - Content metadata
   * @param {string} format - File format ('md', 'txt', 'html')
   * @returns {string} Filename
   */
  generateFilename(metadata, format = 'md') {
    // Clean title for filename
    const cleanTitle = metadata.title
      .replace(/[^a-z0-9]/gi, '_')
      .replace(/_+/g, '_')
      .substring(0, 50)
      .toLowerCase();

    const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

    return `podcast_${cleanTitle}_${timestamp}.${format}`;
  }

  /**
   * Create downloadable blob
   * @param {string} content - Transcript content
   * @param {string} format - File format
   * @returns {Blob} Blob object
   */
  createBlob(content, format = 'md') {
    const mimeTypes = {
      md: 'text/markdown',
      txt: 'text/plain',
      html: 'text/html'
    };

    return new Blob([content], {
      type: mimeTypes[format] || 'text/plain'
    });
  }

  /**
   * Download transcript file
   * @param {string} script - Generated script
   * @param {Object} metadata - Content metadata
   * @param {string} format - File format ('md', 'txt', 'html')
   */
  downloadTranscript(script, metadata, format = 'md') {
    // Format content based on type
    let content;
    switch (format) {
      case 'html':
        content = this.formatAsHTML(script, metadata);
        break;
      case 'txt':
        content = this.formatAsPlainText(script, metadata);
        break;
      case 'md':
      default:
        content = this.formatAsMarkdown(script, metadata);
        break;
    }

    // Create blob
    const blob = this.createBlob(content, format);

    // Generate filename
    const filename = this.generateFilename(metadata, format);

    // Create download link
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';

    // Trigger download
    document.body.appendChild(a);
    a.click();

    // Cleanup
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
  }

  /**
   * Save transcript to chrome storage
   * @param {string} script - Generated script
   * @param {Object} metadata - Content metadata
   * @returns {Promise<void>}
   */
  async saveToHistory(script, metadata) {
    const entry = {
      id: Date.now(),
      title: metadata.title,
      url: metadata.url,
      timestamp: new Date().toISOString(),
      wordCount: this.getWordCount(script),
      difficulty: metadata.difficulty,
      length: metadata.length,
      script: script // Store full script
    };

    try {
      // Get existing history
      const result = await chrome.storage.local.get('transcriptHistory');
      const history = result.transcriptHistory || [];

      // Add new entry at the beginning
      history.unshift(entry);

      // Keep only last 10 entries
      const trimmedHistory = history.slice(0, 10);

      // Save back to storage
      await chrome.storage.local.set({ transcriptHistory: trimmedHistory });

      return entry;
    } catch (error) {
      console.error('Error saving to history:', error);
      throw error;
    }
  }

  /**
   * Get transcript history
   * @returns {Promise<Array>} Array of history entries
   */
  async getHistory() {
    try {
      const result = await chrome.storage.local.get('transcriptHistory');
      return result.transcriptHistory || [];
    } catch (error) {
      console.error('Error getting history:', error);
      return [];
    }
  }

  /**
   * Delete history entry
   * @param {number} entryId - Entry ID to delete
   * @returns {Promise<void>}
   */
  async deleteHistoryEntry(entryId) {
    try {
      const result = await chrome.storage.local.get('transcriptHistory');
      const history = result.transcriptHistory || [];

      const filtered = history.filter(entry => entry.id !== entryId);

      await chrome.storage.local.set({ transcriptHistory: filtered });
    } catch (error) {
      console.error('Error deleting history entry:', error);
      throw error;
    }
  }

  /**
   * Clear all history
   * @returns {Promise<void>}
   */
  async clearHistory() {
    try {
      await chrome.storage.local.set({ transcriptHistory: [] });
    } catch (error) {
      console.error('Error clearing history:', error);
      throw error;
    }
  }

  /**
   * Copy transcript to clipboard
   * @param {string} script - Generated script
   * @param {Object} metadata - Content metadata
   * @param {string} format - Format ('md', 'txt')
   * @returns {Promise<void>}
   */
  async copyToClipboard(script, metadata, format = 'md') {
    let content;
    switch (format) {
      case 'txt':
        content = this.formatAsPlainText(script, metadata);
        break;
      case 'md':
      default:
        content = this.formatAsMarkdown(script, metadata);
        break;
    }

    try {
      await navigator.clipboard.writeText(content);
    } catch (error) {
      console.error('Error copying to clipboard:', error);
      throw error;
    }
  }

  /**
   * Display transcript statistics
   * @param {string} script - Generated script
   * @returns {Object} Statistics
   */
  getStatistics(script) {
    const wordCount = this.getWordCount(script);
    const charCount = script.length;
    const readingTime = this.estimateReadingTime(wordCount);
    const paragraphCount = script.split('\n\n').filter(p => p.trim()).length;
    const sentenceCount = script.split(/[.!?]+/).filter(s => s.trim()).length;

    return {
      wordCount,
      charCount,
      readingTime,
      paragraphCount,
      sentenceCount,
      avgWordsPerSentence: Math.round(wordCount / sentenceCount),
      avgWordsPerParagraph: Math.round(wordCount / paragraphCount)
    };
  }
}

// Export singleton instance (use window to avoid redeclaration)
if (typeof window !== 'undefined') {
  window.transcriptHandler = window.transcriptHandler || new TranscriptHandler();
}
